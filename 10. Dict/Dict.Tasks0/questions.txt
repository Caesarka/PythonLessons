1. Почему операции поиска, добавления и удаления в словаре обычно работают за время, близкое к константному?

Во время указанных выше операций происходит поиск по ключу, который передаётся хеш-функции. Результат - указатель на 
место в памяти - bucket - который хранит непосредственно значение. Т.е. ни в одном из действий (поиск, добавление, удаление) не происходит 
итеративного поиска по всем ключам словаря, а это значит что размер словаря не влияет на производительность.

2. Как изменение размера словаря (например, при добавлении большого количества новых элементов) влияет на структуру хеш-таблицы 
и распределение элементов?

Большое количество элементов может привести к увеличению вероятности коллизий и новый элемент будет размещен в другом месте. В какой-то момент 
закончится место и потребуется перехеширование таблицы. Однако для пользователя эти процессы не видны и почти не влияют на производительность.

3. Предположим, вы часто извлекаете значение по ключу из словаря. Почему производительность этих операций обычно не ухудшается сильно даже при 
значительном росте словаря?

Извлечение значения по ключу происходит мгновенно, независимо от размера словаря.


4. Подумайте, как особенности хранения словаря в памяти могут влиять на расход памяти и производительность программы при работе с очень крупными 
наборами данных. Какие компромиссы могут возникать?

Словарь расходует больше места чем например список, поскольку он должен хранить ключ, значение и хеш ключа. Если данных много то и памяти будет 
расходоваться сильно больше. Производительность словаря может падать в моменты, когда требуется перехеширование 


